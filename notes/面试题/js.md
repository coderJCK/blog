## 深浅拷贝
> 两者的区别本质上来说就是拷贝一个对象`是否需要递归`的问题

> 1、浅拷贝只考虑了该对象的一个层级的属性，没有考虑属性值的数据类型， 拷贝的是属性的值和地址  
> 2、深拷贝不仅考虑了该对象的属性，还考虑了属性值的数据类型，会递归执行拷贝所有对象类型的属性值，拷贝只有值，没有地址。

## 变量提升
先编译，再执行。
- 编译阶段: 变量和函数会被存放到变量环境中，变量的默认值为undefined。
- 执行阶段：js引擎会从变量环境中查找自定义的变量和函数。
**变量提升**：js执行代码过程中，js引擎会把变量和函数的声明部分提升到代码最前面，变量被提升后变量默认值为undefined。
- 函数提升优先级高于变量提升，且不会被覆盖，但是会被变量赋值之后覆盖。(即函数和变量命名冲突，变量不生效，除非被赋值)
- 编辑阶段结束会生成执行上下文(执行一段代码时的运行环境)和可执行代码
## 栈溢出
创建并执行上下文的情况
- 当执行全局代码时，会编译全局代码并创建全局执行上下文，在整个页面生存周期内，全局执行上下文只有一份;
- 当调用一个函数时，函数体内的代码会被编译，并创建函数执行上下文，且在函数执行结束后会被销毁(一般情况);
- 当使用eval函数时，eval的代码也会被编译，并创建执行上下文。

调用栈
- 调用栈：管理函数调用关系的一种数据结构;
- 函数调用：运行一个函数;
- 栈结构：后进先出
- 调用栈是有大小的，当入栈的执行上下文超过一定数目，就会出现栈溢出。比如递归函数没有终止条件。
- 最大栈容量、最大调用深度
## 块级作用域
es6之前只有全局作用域和函数作用域
块级作用域(一对大括号包裹的一段代码，如函数、判断语句、循环语句，以及单独的一个块等)

## this
- 嵌套函数中的this不会从外层函数中继承, 可以使用箭头函数解决
- 普通函数中的this默认指向全局对象window
## 栈内存、堆内存
- **栈空间**通常不会设置太大，主要存放一些原始数据的小数据; **堆空间**很大，主要存放引用类型的数据。
- 原始类型的赋值会完整复制变量的值，引用类型的赋值是复制引用地址
## 垃圾回收机制
- 分类：手动回收(c/c++)和自动回收(java, javascript, python);
- js会通过向下移动ESP(记录当前执行状态的指针)来销毁该函数保存在栈中的执行上下文;
- js使用垃圾回收器回收堆中的数据
