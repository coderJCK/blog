---
title: 基础
---

## 基础

### 数据类型

```
// 基本原始类型
number
string
boolean
undefined
null
symbol
bigInt
// 引用数据类型
object
```

### NaN

```
`NaN` 的全称为 Not a Number，表示非数
任何涉及 NaN 的操作都会返回 NaN
NaN 和任何值都不相等，包括它自己本身
```

### undefined == null

```
区别：undefined是一种初始值，null是手动赋予的空值
比较：比较时会将 undefined 转换成 null，所以undefined == null为ture
```

### 数组去重

1. 数字/字符串数组去重(效率高)

```
1. 声明一个对象
2. 循环原数组
3. 判断每一项在新数组中是否已存在，不存在则将该值作为键名添加到对象中
4. 返回该对象
```

2.  任意数组去重(适配范围广，效率低)

```
1、声明一个新数组
2、循环原数组
3、判断每一项在新数组中是否已存在，不存在则添加到新数组中
4. 返回新数组
```

3. set(适配范围广，效率一般，书写简单)

```
[...new Set(arr)]
```

## ES6

```
var let const
扩展运算符、剩余运算符
箭头函数
set、map
```

## 重要概念

### 事件

```
事件委托/事件代理
```

### 继承

```

```

### 作用域

- 作用域

> - `全局作用域`。在最外层定义的变量或者没有定义在任何函数内的变量
> - `局部作用域`。
>   - `函数作用域`: 在函数内部定义的变量
>   - `块级作用域`: 使用 let 或 const 在代码块内定义的变量(es6 出现)

- 作用域链

> - 当前作用域可以访问到外层作用域中的变量和函数;
> - 外层作用域不能访问到内层作用域中的变量和函数;

### 闭包

> - 闭包就是内层函数中可以访问到外层函数的作用域
> - `弊端`: 可能会导致内存泄漏

### 内存泄漏

1. 产生情况

> - 全局变量
> - 未清理的定时器和回调函数
> - 闭包
> - 脱离 DOM 的引用
> - 循环引用。(两个或多个对象相互引用，形成闭环，如果这些对象之间的引用没有被正确解除)

2. 解决方式

> - 及时释放引用，当不再需要使用一个对象时，确保将其引用设置为 null
> - 及时清理、移除定时器和事件监听管理

### 垃圾回收机制

> - `标记-清除算法`。所有无法被访问到的对象都会被标记为可回收。清除阶段释放内存。
> - `引用计数`。跟踪每个值被引用的次数来决定何时回收内存。
> - `垃圾回收优化`。JavaScript 引擎会进行一系列优化来提高垃圾回收的效率，包括增量标记、延迟清除、增量式垃圾回收、并行垃圾回收等技术。
> - `手动内存管理`。养成良好的内存管理习惯，避免创建不必要的全局变量、及时释放不再需要的对象引用等，以避免内存泄漏问题。

### this 指向

函数的上下文，即函数中的 this 关键字

> - 严格模式，指向 undefined，非严格模式，指向 window;
> - 指向调用对象；
> - 指向构建函数创建的实例化对象；
> - 指向事件调用者
> - 箭头函数没有自身的 this 值；

改变 this 指向的方式

```
fn.call(obj, arg1,arg2,...)
fn.apply(obj, [arg1,arg2,...])
fn.bind()
```

### 深浅拷贝

两者的区别本质上来说就是拷贝一个对象`是否需要递归`的问题

> 1、浅拷贝只考虑了该对象的一个层级的属性，没有考虑属性值的数据类型， 拷贝的是属性的值和地址  
> 2、深拷贝不仅考虑了该对象的属性，还考虑了属性值的数据类型，会递归执行拷贝所有对象类型的属性值，拷贝只有值，没有地址。

### 变量提升

先编译，再执行。

> - 编译阶段: 变量和函数会被存放到变量环境中，变量的默认值为 undefined。
> - 执行阶段：js 引擎会从变量环境中查找自定义的变量和函数。

> **变量提升**：js 执行代码过程中，js 引擎会把变量和函数的声明部分提升到代码最前面，变量被提升后变量默认值为 undefined。
>
> - 函数提升优先级高于变量提升，且不会被覆盖，但是会被变量赋值之后覆盖。(即函数和变量命名冲突，变量不生效，除非被赋值)
> - 编辑阶段结束会生成执行上下文(执行一段代码时的运行环境)和可执行代码

### new 操作符

```
1. 创建一个空的javascript对象
2. 链接该对象到该对象的原型对象
3. 步骤1的对象作为this的上下文
4. 如果该函数没有返回对象，则返回this。
```

### 栈溢出

创建并执行上下文的情况

> - 当执行全局代码时，会编译全局代码并创建全局执行上下文，在整个页面生存周期内，全局执行上下文只有一份;
> - 当调用一个函数时，函数体内的代码会被编译，并创建函数执行上下文，且在函数执行结束后会被销毁(一般情况);
> - 当使用 eval 函数时，eval 的代码也会被编译，并创建执行上下文。

调用栈

> - 调用栈：管理函数调用关系的一种数据结构;
> - 函数调用：运行一个函数;
> - 栈结构：后进先出
> - 调用栈是有大小的，当入栈的执行上下文超过一定数目，就会出现栈溢出。比如递归函数没有终止条件。
> - 最大栈容量、最大调用深度

### 栈内存、堆内存

> - **栈空间**通常不会设置太大，主要存放一些原始数据的小数据; **堆空间**很大，主要存放引用类型的数据。
> - 原始类型的赋值会完整复制变量的值，引用类型的赋值是复制引用地址
