# 概述

## web学习方向：
- 应用程序Web化
- Web应用移动化
- Web操作系统化

## web学习意义
- 准确评估开发可行性
- 高纬度审视页面性能
  - DNS、HTTP、DOM、CSS、JS...
- 了解技术迭代本质
  - 脚本执行速度
    - 如针对js缺陷，修订语言本身(出现es6、7、8、ts)，颠覆性使用新语言(WebAssembly)
  - 前端模块化开发
    - 出现WebComponents标准、前端框架(React、Vue)
  - 渲染效率

# 浏览器

## 多进程的浏览器
### 单进程的弊端
*单进程浏览器情况下*
- **不稳定**——插件、渲染引擎模块不稳定，一旦出问题会导致整个浏览器崩溃
- **不流畅**——插件、页面渲染、页面展示、js环境都运行在页面线程，以及页面的内存泄露问题，都会导致浏览器不流畅
- **不安全**——页面运行一个插件时可以通过插件获取到操作系统的任意资源；页面脚本可以通过浏览器漏洞获取系统权限
### 多进程架构
- **浏览器主进程**: 主要负责页面显示、用户交互、子进程管理、提供存储
- **GPU进程**: 绘制UI、3D CSS等
- **网络进程**: 网络资源加载
- **n个渲染进程**: 主要将html、css、js转化为网页
- **n个插件进程**: 主要运行插件
### 多进程的优势
- 进程之间相互隔离，一个插件或者页面崩溃或者堵塞时，浏览器和其他页面不会收到影响，解决了浏览器不稳定不流畅的问题
- 当一个页面被关闭时，渲染进程也会被关闭，之后该进程占的内存就会被系统回收，解决了浏览器页面的内存泄漏问题
- 插件进程和渲染进程被安全沙箱，相当于被操作系统上了锁，只能运行程序，但是不能写入和读取，解决了安全问题
### 多进程问题
- 占用资源更高: 每个进程都包含公共基础结构都副本(如js运行环境)
- 体系架构更复杂: 浏览器各模块之间耦合性高、扩展性差，会导致架构难以适应新需求

## TCP协议

### DNS
- Domain Name System 域名系统
- 主要作用: 把域名和IP地址做一一映射关系的服务。
### IP
- internet Protocol 网际协议标准
- 计算机的地址就是IP地址
- 主要作用：把数据包发送给指定的电脑
### UDP
- User Datagram Protocol 用户数据包协议 UDP
- 最重要的信息是端口号
- 主要作用：把数据包发送给正确的程序
### TCP
- Transmission Control Protocol 传输控制协议。面向连接的、可靠的、基于字节流的传输层通信协议
- UDP传输的问题：
  - 数据包容易丢失
  - 无法保证能够完整还原较大的文件
- TCP优势
  - 对于数据包丢失的情况，TCP提供重传机制
  - TCP引入了数据包排序机制，保证乱序的数据包组合成完整文件
- TCP 连接
  - 建立连接。 **三次握手**(是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立)
  - 传输数据。 接收端需要对每个数据包进行确认操作，即需要发送确认数据包给发送端，否则在规定时间内没有接收到确认消息就会判断为数据包丢失，会触发发送端的重发机制。
  - 断开连接。**四次挥手**

## HTTP
HTTP是建立在TCP连接基础之上的
### 浏览器端发起HTTP请求流程
  - **构建请求**。 构建请求行
  - **查找缓存**。先在浏览器缓存中查询是否有要请求的文件，如果查找成功，则会拦截请求并返回副本，并直接结束请求；如果查找失败则进入网络请求
  - **准备IP和UDP**。 
  - **等待TCP队列**。Chrome有个机制，同一个域名同时最多只能建立6个TCP连接，只要不超过这个次数，就会直接进行下一步建立连接，否则会进入排队等待状态。
  - **建立TCP连接**。三次握手四次挥手
  - **发送HTTP请求**。 请求行(请求方法、请求url、HTTP协议版本)、请求头(浏览器端的信息)、请求体
### 服务器端处理HTTP请求流程
  - **返回请求**。响应行(HTTP协议版本、状态码)、响应头(服务器端的信息)、响应体
  - **断开连接**。如果头信息中加入了Connection: Keep-Alive,
  - **重定向**。响应行状态码设置301， 响应头中Location设置重定向的地址

## url => 页面展示
- 1.**用户输入**。 判断是搜索内容还是URl。
    - 如果是搜索内容，则会使用浏览器默认的搜索引擎，合成带搜索关键字的url
    - 如果符合url规则，则会把这段内容加上协议，合成为完整的url
    *注：用户输入之后回车，意味着当前页面即将要被替换成新页面，浏览器的beforeunload事件，可以在页面退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，如有未提交完成的表单等。*
- 2.**url请求过程**。
  - 重定向
  - 响应数据类型处理。Content-Type(text/html HTML格式、application/octet-stream下载类型、)
- 3.**准备渲染进程**。
  - 如果多个页面属于同一站点时，那么它们会同时运行在一个渲染进程中
- 4.**提交文档**。
- 5.**渲染阶段**。构建DOM树、样式计算、布局树、分层、绘制图层、删格化、合成

# js执行机制

## 变量提升
先编译，再执行。
- 编译阶段: 变量和函数会被存放到变量环境中，变量的默认值为undefined。
- 执行阶段：js引擎会从变量环境中查找自定义的变量和函数。
**变量提升**：js执行代码过程中，js引擎会把变量和函数的声明部分提升到代码最前面，变量被提升后变量默认值为undefined。
- 函数提升优先级高于变量提升，且不会被覆盖，但是会被变量赋值之后覆盖。(即函数和变量命名冲突，变量不生效，除非被赋值)
- 编辑阶段结束会生成执行上下文(执行一段代码时的运行环境)和可执行代码
## 栈溢出
创建并执行上下文的情况
- 当执行全局代码时，会编译全局代码并创建全局执行上下文，在整个页面生存周期内，全局执行上下文只有一份;
- 当调用一个函数时，函数体内的代码会被编译，并创建函数执行上下文，且在函数执行结束后会被销毁(一般情况);
- 当使用eval函数时，eval的代码也会被编译，并创建执行上下文。

调用栈
- 调用栈：管理函数调用关系的一种数据结构;
- 函数调用：运行一个函数;
- 栈结构：后进先出
- 调用栈是有大小的，当入栈的执行上下文超过一定数目，就会出现栈溢出。比如递归函数没有终止条件。
- 最大栈容量、最大调用深度
## 块级作用域
es6之前只有全局作用域和函数作用域
块级作用域(一对大括号包裹的一段代码，如函数、判断语句、循环语句，以及单独的一个块等)

## this
- 嵌套函数中的this不会从外层函数中继承, 可以使用箭头函数解决
- 普通函数中的this默认指向全局对象window
## 栈内存、堆内存
- **栈空间**通常不会设置太大，主要存放一些原始数据的小数据; **堆空间**很大，主要存放引用类型的数据。
- 原始类型的赋值会完整复制变量的值，引用类型的赋值是复制引用地址
## 垃圾回收机制
- 分类：手动回收(c/c++)和自动回收(java, javascript, python);
- js会通过向下移动ESP(记录当前执行状态的指针)来销毁该函数保存在栈中的执行上下文;
- js使用垃圾回收器回收堆中的数据
