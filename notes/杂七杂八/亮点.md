## 图片压缩
- 一般处理方式canvas、Compressor.js
问题：使用图像处理库进行处理时，会卡顿、耗时
原因：设计大量数学运算，属于计算密集型任务，而js是单线程，不擅长处理计算密集型任务，会阻塞其他操作。
解决：
1、服务端解决。但涉及网络通信问题，不确定因素较多
2、客户端解决。使用WebAssembly、Web Worker

1、WebAssembly
  - 二进制格式，接近于机器码，性能接近于原生代码
  - 能与js互操作，使用其他语言编写和性能相关的关键的代码，并将其编译成WebAssembly模块，以提升计算密集型任务的性能。
  Emscripten
  二进制格式的.wasm文件、一个js文件，即胶水代码
2、Web worker优化
  允许在主线程之外允许脚本，以避免阻塞用户界面。
3、OffscreenCanvas再优化
  在主线程之外绘制图像，自动更新主线程显示
4、requestCallback
  允许浏览器在空闲时间执行低优先级任务，从而不阻塞用户界面响应。

## webpack构建优化
webpack的构建流程
问题：启动项目时间长
原因：webpack，即便是在开发环境下，也必须先打包才能在浏览器看到效果

分析工具
  1、speed-measure-webpack-plugin 主要分析构建时间
    总耗时、各个阶段耗时、插件耗时、loader耗时
  2、webpack bundle analyzer 主要分析构建包大小
解决：
1、js编译：babel编译 —— speedy web complier 替换 babel，rust编写的编译器(高性能、兼容性、生态系统)
2、打包时间：模块打包 —— 使用thread-loader，开始多线程，减少主线程负载(大型项目才有效果，小项目可能会增加打包时间)
3、插件耗时 —— webpack5持久化缓存技术
  缓存的内容(模块、解析、插件)
  - memory 缓存在内存中，适用于开发环境
  - filesystem 以文件的形式，缓存在磁盘中，适用于生产环境
4、文件读取与写入 —— 开发环境去掉hash(为生成唯一文件名)，生产环境保留、涉及浏览器缓存问题
5、热更新 —— 升级老旧的plugin，例如terser-webpack-plugin

## vite性能优化
- 对vite的整体认知程度
  esbuild依赖预构建
  按需加载存在bug
- 性能优化、优化指标是什么
- 优化方式
- 优化结果

## TTS性能优化
Text-Speech 文字转语音
- 应用：阅读器应用、导航系统、在线教育平台
- WebApi实现：不同操作系统音效不同、无法定制化、存在一定兼容性问题
- 三方平台实现：大文本转换耗时、音频大也耗时、添加情绪
- 解决思路：文本分割、添加自然语言处理库进行情绪标记、转换文本进行缓存、并发控制
## 实时协作
## 网页复制成剪贴板
## vite插件
## 公共表单模块
## 虚拟列表
## 微前端
## DNS解析与优化
## 前端监控
## 跨标签页通信
## 计时器节流优化
## 多文件预览
## defer优化白屏时间

