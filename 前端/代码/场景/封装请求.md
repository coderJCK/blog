é¡¹ç›®çš„éš¾ç‚¹å’Œäº®ç‚¹
æè‡´çš„ä¼˜åŒ–å’Œå°è£…äº† Axios è¯·æ±‚æ•°æ®çš„ä½“éªŒ(è¯·æ±‚é‡è¯•ï¼Œè¯·æ±‚ç¼“å­˜ï¼Œè¯·æ±‚ç«æ€, å‚æ•°åŠ å¯†)

ä¸€ã€ä¸ºä»€ä¹ˆè¦å°è£…ï¼Ÿ
éšç€é¡¹ç›®è§„æ¨¡å¢å¤§ï¼Œå¦‚æœæ¯å‘èµ·ä¸€æ¬¡HTTPè¯·æ±‚ï¼Œå°±è¦æŠŠè¿™äº›æ¯”å¦‚è®¾ç½®è¶…æ—¶æ—¶é—´ã€è®¾ç½®è¯·æ±‚å¤´ã€æ ¹æ®é¡¹ç›®ç¯å¢ƒåˆ¤æ–­ä½¿ç”¨å“ªä¸ªè¯·æ±‚åœ°å€ã€é”™è¯¯å¤„ç†ç­‰ç­‰æ“ä½œï¼Œéƒ½éœ€è¦å†™ä¸€éï¼Œè¿™ç§é‡å¤åŠ³åŠ¨ä¸ä»…æµªè´¹æ—¶é—´ï¼Œè€Œä¸”è®©ä»£ç å˜å¾—å†—ä½™ä¸å ªï¼Œéš¾ä»¥ç»´æŠ¤ã€‚æ€»çš„æ¥è¯´ï¼Œå¯¹ axios è¿›è¡ŒäºŒæ¬¡å°è£…æœ‰å¦‚ä¸‹å¥½å¤„ï¼š
1. ä»£ç å°è£…ï¼Œé‡ç”¨æ€§é«˜ï¼Œå‡å°‘ä»£ç é‡ï¼Œå‡å°‘ç»´æŠ¤éš¾åº¦
2. ç»Ÿä¸€å¤„ç†ä¸€äº›å¸¸è§„çš„é—®é¢˜ï¼Œä¸€åŠ³æ°¸é€¸ï¼Œæ¯”å¦‚ HTTP é”™è¯¯
3. æ‹¦æˆªè¯·æ±‚å’Œå“åº”ï¼Œæå‰å¯¹æ•°æ®è¿›è¡Œå¤„ç†ï¼Œå¦‚è·å– TOKENï¼Œä¿®æ”¹é…ç½®é¡¹
å¦‚æœå¯¹ axios çš„ç”¨æ³•ä¸ç†Ÿæ‚‰çš„è¯ï¼Œå¯ä»¥å»å‚è€ƒ axioså®˜æ–¹æ–‡æ¡£ è¿›è¡Œå­¦ä¹ ã€‚æœ¬æ–‡æœ‰ç‚¹é•¿ï¼Œå¸Œæœ›èƒ½å¤Ÿæœ‰è€å¿ƒé˜…è¯»å®Œï¼Œç›¸ä¿¡å¯¹æ‚¨æœ‰æ‰€å¸®åŠ©ï¼
äºŒã€å¦‚ä½•äºŒæ¬¡å°è£…ï¼Ÿ
æ—¢ç„¶æ˜¯äºŒæ¬¡å°è£…ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸€å®šè¦åšå¥½é€šç”¨æ€§ä»¥åŠæ‰©å±•æ€§ï¼Œè¦èƒ½å¤Ÿæ»¡è¶³æˆ‘ä»¬é¡¹ç›®å¼€å‘çš„å¤§éƒ¨åˆ†éœ€æ±‚ï¼ŒåŒæ—¶å°½å¯èƒ½æä¾›å¤šçš„åŠŸèƒ½ï¼Œæ¯”å¦‚ï¼š
â— æ ¹æ®å¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒçš„ä¸åŒï¼Œæ¥å£è¯·æ±‚å‰ç¼€éœ€è¦åŠ ä»¥åŒºåˆ†
â— è¯·æ±‚ä¹‹å‰å¤„ç† config
â— æ ¹æ®æ¥å£è¿”å›çš„ä¸åŒçŠ¶æ€ç åšä¸åŒçš„å¤„ç†
â— å¯¹ Getã€Post ç­‰æ–¹æ³•è¿›è¡Œå°è£…ï¼Œä½¿ç”¨èµ·æ¥æ›´æ–¹ä¾¿
â— é’ˆå¯¹æ–‡ä»¶ä¸Šä¼ å°è£…ç»Ÿä¸€çš„è¯·æ±‚æ–¹æ³•
â— åœ¨å“åº”æ‹¦æˆªå™¨ä¸­è¿›è¡Œé”™è¯¯æ•è·
â— å…·å¤‡å–æ¶ˆé‡å¤è¯·æ±‚ã€é”™è¯¯è¯·æ±‚é‡è¿çš„åŠŸèƒ½
â— å¯¹æ¥å£è¿”å›çš„æ•°æ®è¿›è¡Œå¤„ç†ï¼Œå°è£…æ¶ˆæ¯æç¤ºæ–¹æ³•
ä¸‰ã€å‰ç½®çŸ¥è¯†å‡†å¤‡
1. è¯·æ±‚å°è£…çš„ç›®å½•ç»“æ„

â— Axios.tsï¼šè¯·æ±‚å®ä½“ç±»ï¼ŒåŒ…æ‹¬å®ä¾‹åˆ›å»ºã€æ‹¦æˆªå™¨é…ç½®ã€è¯·æ±‚æ–¹æ³•å°è£…
â— axiosCancel.tsï¼šè¯·æ±‚å–æ¶ˆå®ä½“ç±»ï¼Œå…·å¤‡æ·»åŠ è¯·æ±‚ã€ç§»é™¤è¯·æ±‚ã€æ¸…ç©ºè¯·æ±‚ç­‰æ–¹æ³•
â— axiosRetry.tsï¼šé”™è¯¯è¯·æ±‚é‡è¿å®ä½“ç±»ï¼Œè¯·æ±‚é‡è¯•æœºåˆ¶çš„å…·ä½“é€»è¾‘
â— axiosTransform.tsï¼šæ‹¦æˆªå™¨ã€é”™è¯¯è¯·æ±‚ã€æ•°æ®å¤„ç†çš„å…·ä½“é€»è¾‘
â— checkStatus.tsï¼šæ ¹æ®æ¥å£è¿”å›çš„ä¸åŒçŠ¶æ€ç åšä¸åŒçš„å¤„ç†
â— helper.tsï¼šè¾…åŠ©ã€å·¥å…·ç±»å‡½æ•°
â— index.tsï¼šè¯·æ±‚è°ƒç”¨å…¥å£ï¼Œè¿”å›ä¸€ä¸ªè¯·æ±‚å®ä½“ç±»å¯¹è±¡
2. å®šä¹‰è¯·æ±‚çš„ç›¸å…³ç±»å‹
/**
 * @description: è¯·æ±‚ç»“æœç±»å‹
 */
export enum ResultEnum {
  SUCCESS = 0,
    ERROR = 1,
    TIMEOUT = 401,
    TYPE = 'success',
    }

/**
 * @description: è¯·æ±‚æ–¹æ³•ç±»å‹
 */
export enum RequestEnum {
  GET = 'GET',
    POST = 'POST',
    PUT = 'PUT',
    DELETE = 'DELETE',
    }

/**
 * @description:  Contentç±»å‹
 */
export enum ContentTypeEnum {
  // json
  JSON = 'application/json;charset=UTF-8',
    // form-data qs
    FORM_URLENCODED = 'application/x-www-form-urlencoded;charset=UTF-8',
    // form-data  upload
    FORM_DATA = 'multipart/form-data;charset=UTF-8',
    }

/**
 * @description:  è¯·æ±‚å¤´ç±»å‹
 */
export enum ConfigEnum {
  // TOKEN
  TOKEN = 'X-Access-Token',
    // TIMESTAMP
    TIMESTAMP = 'X-TIMESTAMP'
}

export type ErrorMessageMode = 'none' | 'modal' | 'message' | undefined;
export type SuccessMessageMode = 'none' | 'success' | 'error' | undefined;

export interface RequestOptions {
  // å°†è¯·æ±‚å‚æ•°æ‹¼æ¥åˆ°url
  joinParamsToUrl?: boolean;
  // æ ¼å¼åŒ–è¯·æ±‚å‚æ•°æ—¶é—´
  formatDate?: boolean;
  // æ˜¯å¦å¤„ç†è¯·æ±‚ç»“æœ
  isTransformResponse?: boolean;
  // æ˜¯å¦è¿”å›æœ¬åœ°å“åº”å¤´,éœ€è¦è·å–å“åº”å¤´æ—¶ä½¿ç”¨æ­¤å±æ€§
  isReturnNativeResponse?: boolean;
  // Whether to join url
  joinPrefix?: boolean;
  // æ¥å£åœ°å€ï¼Œå¦‚æœä¿ç•™ä¸ºç©ºï¼Œåˆ™ä½¿ç”¨é»˜è®¤å€¼
  apiUrl?: string;
  // è¯·æ±‚æ‹¼æ¥è·¯å¾„
  urlPrefix?: string;
  // é”™è¯¯æ¶ˆæ¯æç¤ºç±»å‹
  errorMessageMode?: ErrorMessageMode;
  // æˆåŠŸæ¶ˆæ¯æç¤ºç±»å‹
  successMessageMode?: SuccessMessageMode;
  // æ˜¯å¦æ·»åŠ æ—¶é—´æˆ³
  joinTime?: boolean;
  ignoreCancelToken?: boolean;
  //æ˜¯å¦åœ¨æ ‡å¤´ä¸­å‘é€ä»¤ç‰Œ
  withToken?: boolean;
  // è¯·æ±‚é‡è¯•æœºåˆ¶
  retryRequest?: RetryRequest;
}

export interface RetryRequest {
  isOpenRetry: boolean;
  count: number;
  waitTime: number;
}

export interface Result<T = any> {
  code: number;
type: 'success' | 'error' | 'warning';
message: string;
result: T;
info: T;
msg: string;
}
ä¸‰ã€å…·ä½“å°è£…ç»†èŠ‚
æŠŠä¸Šé¢åˆ—å‡ºçš„ä¸€äº›å†…å®¹å‡†å¤‡å¥½ä»¥åï¼Œä¾¿å¯ä»¥å¼€å§‹è¿›è¡Œ axios çš„äºŒæ¬¡å°è£…å•¦ï¼
1. åˆ›å»ºè¯·æ±‚å®ä½“ç±»
æˆ‘ä»¬ä¸»è¦å…³æ³¨ class VAxios é‡Œçš„é€»è¾‘ï¼ˆå…¶ä»–çš„å¼•ç”¨ä»£ç å¯ä»¥ä¸ç®¡ï¼‰ï¼ŒåŒ…æ‹¬åˆ›å»º axios å®ä¾‹ï¼Œè¯·æ±‚æ‹¦æˆªå™¨ã€å“åº”æ‹¦æˆªå™¨çš„é…ç½®ï¼Œä¸è¿‡è¿™é‡Œå°†æ‹¦æˆªå™¨é‡Œçš„å…·ä½“é€»è¾‘æŠ½ç¦»åˆ°å…¶ä»–æ–‡ä»¶ä¸­ï¼Œå¾…ä¼šå†åˆ†æå…·ä½“çš„é€»è¾‘ã€‚
import type { AxiosRequestConfig, AxiosInstance, AxiosResponse } from 'axios';
import axios from 'axios';
import { AxiosCanceler } from './axiosCancel';
import { isFunction } from '@/utils/is';
import { cloneDeep } from 'lodash-es';
import type { RequestOptions, CreateAxiosOptions, Result, UploadFileParams } from './types';
import { ContentTypeEnum } from '@/enums/httpEnum';
export * from './axiosTransform';

/**
 * @description:  axiosæ¨¡å—
 */
export class VAxios {
  private axiosInstance: AxiosInstance;
  private options: CreateAxiosOptions;

  constructor(options: CreateAxiosOptions) {
    this.options = options;
    this.axiosInstance = axios.create(options);
    this.setupInterceptors();
  }

  getAxios(): AxiosInstance {
    return this.axiosInstance;
  }

  /**
   * @description: é‡æ–°é…ç½®axios
   */
  configAxios(config: CreateAxiosOptions) {
    if (!this.axiosInstance) {
      return;
    }
    this.createAxios(config);
  }

  /**
   * @description: è®¾ç½®é€šç”¨header
   */
  setHeader(headers: any): void {
    if (!this.axiosInstance) {
      return;
    }
    Object.assign(this.axiosInstance.defaults.headers, headers);
  }

  /**
   * @description:  åˆ›å»ºaxioså®ä¾‹
   */
  private createAxios(config: CreateAxiosOptions): void {
    this.axiosInstance = axios.create(config);
  }

  private getTransform() {
    const { transform } = this.options;
    return transform;
  }

  /**
   * @description: æ‹¦æˆªå™¨é…ç½®
   */
  private setupInterceptors() {
    const transform = this.getTransform();
    if (!transform) {
      return;
    }
    const {
      requestInterceptors,
      requestInterceptorsCatch,
      responseInterceptors,
      responseInterceptorsCatch,
    } = transform;

    const axiosCanceler = new AxiosCanceler();

    // è¯·æ±‚æ‹¦æˆªå™¨é…ç½®å¤„ç†
    this.axiosInstance.interceptors.request.use((config: AxiosRequestConfig) => {
      const {
        headers: { ignoreCancelToken },
      } = config;
      const ignoreCancel =
        ignoreCancelToken !== undefined
        ? ignoreCancelToken
        : this.options.requestOptions?.ignoreCancelToken;

      !ignoreCancel && axiosCanceler.addPending(config);
      if (requestInterceptors && isFunction(requestInterceptors)) {
        config = requestInterceptors(config, this.options);
      }
      return config;
    }, undefined);

    // è¯·æ±‚æ‹¦æˆªå™¨é”™è¯¯æ•è·
    requestInterceptorsCatch &&
      isFunction(requestInterceptorsCatch) &&
      this.axiosInstance.interceptors.request.use(undefined, requestInterceptorsCatch);

    // å“åº”ç»“æœæ‹¦æˆªå™¨å¤„ç†
    this.axiosInstance.interceptors.response.use((res: AxiosResponse<any>) => {
      res && axiosCanceler.removePending(res.config);
      if (responseInterceptors && isFunction(responseInterceptors)) {
        res = responseInterceptors(res);
      }
      return res;
    }, undefined);

    // å“åº”ç»“æœæ‹¦æˆªå™¨é”™è¯¯æ•è·
    responseInterceptorsCatch &&
      isFunction(responseInterceptorsCatch) &&
      this.axiosInstance.interceptors.response.use(undefined, responseInterceptorsCatch);
  }
  }
ä¸‹é¢æˆ‘ä»¬åœ¨ axios å®ä¾‹ç±»ä¸­å°è£…è¯·æ±‚æ–¹æ³•ï¼ˆGetã€Postã€Putã€Deleteï¼‰ï¼š
/**
 * @description:  axiosæ¨¡å—
 */
export class VAxios {
  ........
  ........

  /**
   * @description:   è¯·æ±‚æ–¹æ³•
   */
  request<T = any>(config: AxiosRequestConfig, options?: RequestOptions): Promise<T> {
    let conf: AxiosRequestConfig = cloneDeep(config);
    const transform = this.getTransform();

    const { requestOptions } = this.options;

    const opt: RequestOptions = Object.assign({}, requestOptions, options);

    const { beforeRequestHook, requestCatch, transformRequestData } = transform || {};
    if (beforeRequestHook && isFunction(beforeRequestHook)) {
      conf = beforeRequestHook(conf, opt);
    }

    //è¿™é‡Œé‡æ–° èµ‹å€¼æˆæœ€æ–°çš„é…ç½®
    // @ts-ignore
    conf.requestOptions = opt;

    return new Promise((resolve, reject) => {
      this.axiosInstance
        .request<any, AxiosResponse<Result>>(conf)
        .then((res: AxiosResponse<Result>) => {
          // è¯·æ±‚æ˜¯å¦è¢«å–æ¶ˆ
          const isCancel = axios.isCancel(res);
          if (transformRequestData && isFunction(transformRequestData) && !isCancel) {
            try {
              const ret = transformRequestData(res, opt);
              resolve(ret);
            } catch (err) {
              reject(err || new Error('request error!'));
            }
            return;
          }
          resolve(res as unknown as Promise<T>);
        })
        .catch((e: Error) => {
          if (requestCatch && isFunction(requestCatch)) {
            reject(requestCatch(e));
            return;
          }
          reject(e);
        });
    });
  }

  get<T = any>(config: AxiosRequestConfig, options?: RequestOptions): Promise<T> {
    return this.request({ ...config, method: 'GET' }, options);
  }

  post<T = any>(config: AxiosRequestConfig, options?: RequestOptions): Promise<T> {
    return this.request({ ...config, method: 'POST' }, options);
  }

  put<T = any>(config: AxiosRequestConfig, options?: RequestOptions): Promise<T> {
    return this.request({ ...config, method: 'PUT' }, options);
  }

  delete<T = any>(config: AxiosRequestConfig, options?: RequestOptions): Promise<T> {
    return this.request({ ...config, method: 'DELETE' }, options);
  }
}
2. çŠ¶æ€ç ç»Ÿä¸€å¤„ç†
import type { ErrorMessageMode } from '/#/axios';
import { useMessage } from '/@/hooks/web/useMessage';
import { useUserStoreWithOut } from '/@/store/modules/user';
import projectSetting from '/@/settings/projectSetting';
import { SessionTimeoutProcessingEnum } from '/@/enums/appEnum';

const { createMessage, createErrorModal } = useMessage();
const error = createMessage.error!;
const stp = projectSetting.sessionTimeoutProcessing;

export function checkStatus(status: number, msg: string, errorMessageMode: ErrorMessageMode = 'message'): void {
  const userStore = useUserStoreWithOut();
  let errMessage = '';

  switch (status) {
    case 400:
      errMessage = `${msg}`;
      break;
    case 401:
      userStore.setToken(undefined);
      errMessage = msg || 'ç”¨æˆ·æ²¡æœ‰æƒé™ï¼ˆä»¤ç‰Œã€ç”¨æˆ·åã€å¯†ç é”™è¯¯ï¼‰!';
      if (stp === SessionTimeoutProcessingEnum.PAGE_COVERAGE) {
        userStore.setSessionTimeout(true);
      } else {
        userStore.logout(true);
      }
      break;
    case 403:
      errMessage = 'ç”¨æˆ·å¾—åˆ°æˆæƒï¼Œä½†æ˜¯è®¿é—®æ˜¯è¢«ç¦æ­¢çš„!';
      break;
    case 404:
      errMessage = 'ç½‘ç»œè¯·æ±‚é”™è¯¯,æœªæ‰¾åˆ°è¯¥èµ„æº!';
      break;
    case 405:
      errMessage = 'ç½‘ç»œè¯·æ±‚é”™è¯¯,è¯·æ±‚æ–¹æ³•æœªå…è®¸!';
      break;
    case 408:
      errMessage = 'ç½‘ç»œè¯·æ±‚è¶…æ—¶!';
      break;
    case 500:
      errMessage = 'æœåŠ¡å™¨é”™è¯¯,è¯·è”ç³»ç®¡ç†å‘˜!';
      break;
    case 501:
      errMessage = 'ç½‘ç»œæœªå®ç°!';
      break;
    case 502:
      errMessage = 'ç½‘ç»œé”™è¯¯!';
      break;
    case 503:
      errMessage = 'æœåŠ¡ä¸å¯ç”¨ï¼ŒæœåŠ¡å™¨æš‚æ—¶è¿‡è½½æˆ–ç»´æŠ¤!';
      break;
    case 504:
      errMessage = 'ç½‘ç»œè¶…æ—¶!';
      break;
    case 505:
      errMessage = 'httpç‰ˆæœ¬ä¸æ”¯æŒè¯¥è¯·æ±‚!';
      break;
    default:
  }

  if (errMessage) {
    if (errorMessageMode === 'modal') {
      createErrorModal({ title: 'é”™è¯¯æç¤º', content: errMessage });
    } else if (errorMessageMode === 'message') {
      error({ content: errMessage, key: `global_error_message_status_${status}` });
    }
  }
}
åœ¨å“åº”é”™è¯¯å¤„ç†æ–¹æ³•ä¸­ï¼Œè°ƒç”¨ checkStatus æ–¹æ³•ï¼Œæ˜¾ç¤ºä¸åŒçŠ¶æ€ç å¯¹åº”çš„ä¿¡æ¯
3. å°è£…è¾…åŠ©ç±»å‡½æ•°
ä¸‹é¢çš„è¿™ä¸¤ä¸ªæ–¹æ³•ï¼Œåœ¨è¯·æ±‚ä¹‹å‰å¤„ç† config ä¸­ä¼šç”¨åˆ°ï¼Œéƒ½æ˜¯ä¸æ—¶é—´æœ‰å…³çš„
import { isObject, isString } from '/@/utils/is';

const DATE_TIME_FORMAT = 'YYYY-MM-DD HH:mm';

/**
 * @description: æ‹¼æ¥æ—¶é—´æˆ³
 */
export function joinTimestamp(join: boolean, restful = false): string | object {
  if (!join) {
    return restful ? '' : {};
  }
  const now = new Date().getTime();
  if (restful) {
    return `?_t=${now}`;
  }
  return { _t: now };
}

/**
 * @description: æ ¼å¼åŒ–è¯·æ±‚å‚æ•°ä¸­çš„æ—¶é—´
 */
export function formatRequestDate(params: Recordable) {
  if (Object.prototype.toString.call(params) !== '[object Object]') {
    return;
  }

  for (const key in params) {
    if (params[key] && params[key]._isAMomentObject) {
      params[key] = params[key].format(DATE_TIME_FORMAT);
    }
    if (isString(key)) {
      const value = params[key];
      if (value) {
        try {
          params[key] = isString(value) ? value.trim() : value;
        } catch (error: any) {
          throw new Error(error);
        }
      }
    }
    if (isObject(params[key])) {
      formatRequestDate(params[key]);
    }
  }
}
4. å–æ¶ˆé‡å¤è¯·æ±‚
å½“å‘èµ·ä¸€ä¸ªè¯·æ±‚è¿˜æ²¡å¾—åˆ°å“åº”æ—¶ï¼Œåˆå‘èµ·ç›¸åŒçš„è¯·æ±‚ï¼Œä¸ºäº†èŠ‚çœç½‘ç»œèµ„æºï¼Œæ­¤æ—¶éœ€è¦å°†å‰ä¸€ä¸ªè¯·æ±‚å–æ¶ˆï¼Œä¿ç•™æœ€è¿‘å‘èµ·çš„è¯·æ±‚ã€‚
import axios, { AxiosRequestConfig, Canceler } from 'axios';
import qs from 'qs';

import { isFunction } from '@/utils/is/index';

// å£°æ˜ä¸€ä¸ª Map ç”¨äºå­˜å‚¨æ¯ä¸ªè¯·æ±‚çš„æ ‡è¯† å’Œ å–æ¶ˆå‡½æ•°
let pendingMap = new Map<string, Canceler>();

export const getPendingUrl = (config: AxiosRequestConfig) =>
  [config.method, config.url, qs.stringify(config.data), qs.stringify(config.params)].join('&');

export class AxiosCanceler {
  /**
   * æ·»åŠ è¯·æ±‚
   * @param {Object} config
   */
  addPending(config: AxiosRequestConfig) {
    this.removePending(config);
    const url = getPendingUrl(config);
    config.cancelToken =
      config.cancelToken ||
      new axios.CancelToken((cancel) => {
        if (!pendingMap.has(url)) {
          // å¦‚æœ pending ä¸­ä¸å­˜åœ¨å½“å‰è¯·æ±‚ï¼Œåˆ™æ·»åŠ è¿›å»
          pendingMap.set(url, cancel);
        }
      });
  }

  /**
   * @description: æ¸…ç©ºæ‰€æœ‰pending
   */
  removeAllPending() {
    pendingMap.forEach((cancel) => {
      cancel && isFunction(cancel) && cancel();
    });
    pendingMap.clear();
  }

  /**
   * ç§»é™¤è¯·æ±‚
   * @param {Object} config
   */
  removePending(config: AxiosRequestConfig) {
    const url = getPendingUrl(config);

    if (pendingMap.has(url)) {
      // å¦‚æœåœ¨ pending ä¸­å­˜åœ¨å½“å‰è¯·æ±‚æ ‡è¯†ï¼Œéœ€è¦å–æ¶ˆå½“å‰è¯·æ±‚ï¼Œå¹¶ä¸”ç§»é™¤
      const cancel = pendingMap.get(url);
      cancel && cancel(url);
      pendingMap.delete(url);
    }
  }

  /**
   * @description: é‡ç½®
   */
  reset(): void {
    pendingMap = new Map<string, Canceler>();
  }
}
AxiosCanceler ç±»çš„ä½¿ç”¨æ—¶æœºï¼šé¦–å…ˆå‡†å¤‡ä¸€ä¸ª Map ç”¨äºå­˜å‚¨æ¯ä¸ªè¯·æ±‚çš„æ ‡è¯†å’Œå–æ¶ˆå‡½æ•°ï¼Œåœ¨è¯·æ±‚æ‹¦æˆªå™¨ä¸­è°ƒç”¨æ·»åŠ è¯·æ±‚çš„æ–¹æ³•ï¼Œç„¶ååˆ¤æ–­ Map ç»“æ„ä¸­æ˜¯å¦å·²æœ‰è¯¥è¯·æ±‚ï¼Œå¦‚æœæ˜¯é‡å¤è¯·æ±‚ï¼Œåˆ™å°†ä¹‹å‰çš„è¯·æ±‚å–æ¶ˆæ‰ï¼Œaxios.CancelToken å¯ä»¥å®ç°å–æ¶ˆè¯·æ±‚ï¼›åä¹‹å°†è¯¥è¯·æ±‚æ”¾å…¥ Map ç»“æ„ä¸­ï¼›åœ¨å“åº”æ‹¦æˆªå™¨ä¸­ï¼Œå½“è¯·æ±‚å·²ç»å®Œæˆåï¼Œè°ƒç”¨æ–¹æ³•ä» Map ç»“æ„ä¸­ç§»é™¤è¯·æ±‚ã€‚

5. é”™è¯¯è¯·æ±‚é‡è¿
import { AxiosError, AxiosInstance } from 'axios';
/**
 *  è¯·æ±‚é‡è¯•æœºåˆ¶
 */

export class AxiosRetry {
  /**
   * é‡è¯•
   */
  retry(axiosInstance: AxiosInstance, error: AxiosError) {
    // @ts-ignore
    const { config } = error.response;
    const { waitTime, count } = config?.requestOptions?.retryRequest ?? {};
    config.__retryCount = config.__retryCount || 0;
    if (config.__retryCount >= count) {
      return Promise.reject(error);
    }
    config.__retryCount += 1;
    //è¯·æ±‚è¿”å›åconfigçš„headerä¸æ­£ç¡®é€ æˆé‡è¯•è¯·æ±‚å¤±è´¥,åˆ é™¤è¿”å›headersé‡‡ç”¨é»˜è®¤headers
    delete config.headers;
    return this.delay(waitTime).then(() => axiosInstance(config));
  }

  /**
   * å»¶è¿Ÿ
   */
  private delay(waitTime: number) {
    return new Promise((resolve) => setTimeout(resolve, waitTime));
  }
}
åŒæ ·æ˜¯åœ¨å“åº”é”™è¯¯å¤„ç†æ–¹æ³•ä¸­ä½¿ç”¨ AxiosRetry ç±»ï¼Œå¯ä»¥åœ¨è¯·æ±‚å‚æ•°ä¸­é…ç½®æ˜¯å¦å¼€å¯è¯·æ±‚é‡è¿ï¼ŒåŒæ—¶å¯ä»¥è®¾ç½®æœ€å¤§é‡è¯•æ¬¡æ•°ä»¥åŠç­‰å¾…æ—¶é—´ï¼š


6. æ‹¦æˆªå™¨å…·ä½“é€»è¾‘ã€æ•°æ®ï¼ˆé”™è¯¯ï¼‰å¤„ç†
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import type { RequestOptions, Result } from '/#/axios';
import { checkStatus } from './checkStatus';
import { RequestEnum, ResultEnum, ConfigEnum } from '/@/enums/httpEnum';
import { useMessage } from '/@/hooks/web/useMessage';
import { isString } from '/@/utils/is';
import { getToken } from '/@/utils/auth';
import { useErrorLogStoreWithOut } from '/@/store/modules/errorLog';
import { setObjToUrlParams } from '/@/utils';
import { joinTimestamp, formatRequestDate } from './helper';
import { useUserStoreWithOut } from '/@/store/modules/user';
import { AxiosRetry } from '/@/utils/http/axios/axiosRetry';
const { createMessage, createErrorModal } = useMessage();

export interface CreateAxiosOptions extends AxiosRequestConfig {
  authenticationScheme?: string;
transform?: AxiosTransform;
requestOptions?: RequestOptions;
}

export abstract class AxiosTransform {
  /**
   * @description: Process configuration before request
   * @description: Process configuration before request
   */
  beforeRequestHook?: (config: AxiosRequestConfig, options: RequestOptions) => AxiosRequestConfig;

  /**
   * @description: Request successfully processed
   */
  transformRequestHook?: (res: AxiosResponse<Result>, options: RequestOptions) => any;

  /**
   * @description: è¯·æ±‚å¤±è´¥å¤„ç†
   */
  requestCatchHook?: (e: Error, options: RequestOptions) => Promise<any>;

  /**
   * @description: è¯·æ±‚ä¹‹å‰çš„æ‹¦æˆªå™¨
   */
  requestInterceptors?: (config: AxiosRequestConfig, options: CreateAxiosOptions) => AxiosRequestConfig;

  /**
   * @description: è¯·æ±‚ä¹‹åçš„æ‹¦æˆªå™¨
   */
  responseInterceptors?: (res: AxiosResponse<any>) => AxiosResponse<any>;

  /**
   * @description: è¯·æ±‚ä¹‹å‰çš„æ‹¦æˆªå™¨é”™è¯¯å¤„ç†
   */
  requestInterceptorsCatch?: (error: Error) => void;

  /**
   * @description: è¯·æ±‚ä¹‹åçš„æ‹¦æˆªå™¨é”™è¯¯å¤„ç†
   */
  responseInterceptorsCatch?: (error: Error) => void;
}
/**
 * @description: æ•°æ®å¤„ç†ï¼Œæ–¹ä¾¿åŒºåˆ†å¤šç§å¤„ç†æ–¹å¼
 */
export const transform: AxiosTransform = {
  /**
   * @description: å¤„ç†è¯·æ±‚æ•°æ®ã€‚å¦‚æœæ•°æ®ä¸æ˜¯é¢„æœŸæ ¼å¼ï¼Œå¯ç›´æ¥æŠ›å‡ºé”™è¯¯
   */
  transformRequestHook: (res: AxiosResponse<Result>, options: RequestOptions) => {
    const { isTransformResponse, isReturnNativeResponse } = options;

    // æ˜¯å¦è¿”å›åŸç”Ÿå“åº”å¤´ æ¯”å¦‚ï¼šéœ€è¦è·å–å“åº”å¤´æ—¶ä½¿ç”¨è¯¥å±æ€§
    if (isReturnNativeResponse) {
      return res;
    }
    // ä¸è¿›è¡Œä»»ä½•å¤„ç†ï¼Œç›´æ¥è¿”å›
    // ç”¨äºé¡µé¢ä»£ç å¯èƒ½éœ€è¦ç›´æ¥è·å–codeï¼Œdataï¼Œmessageè¿™äº›ä¿¡æ¯æ—¶å¼€å¯
    if (!isTransformResponse) {
      return res.data;
    }
    // é”™è¯¯çš„æ—¶å€™è¿”å›

    const { data } = res;
    if (!data) {
      throw new Error('è¯·æ±‚å‡ºé”™ï¼Œè¯·ç¨å€™é‡è¯•');
    }
    //  è¿™é‡Œ codeï¼Œresultï¼Œmessageä¸º åå°ç»Ÿä¸€çš„å­—æ®µï¼Œéœ€è¦ä¿®æ”¹ä¸ºè‡ªå·±é¡¹ç›®ä¸­çš„æ¥å£è¿”å›æ ¼å¼
    const { code, result, message, success, info, msg } = data;
    // è¿™é‡Œé€»è¾‘å¯ä»¥æ ¹æ®é¡¹ç›®è¿›è¡Œä¿®æ”¹
    // å…¼å®¹å¯¼å‡ºæ¥å£
    let hasSuccess = true;
    if (Object.prototype.toString.call(data) === '[object Object]') {
      hasSuccess = data && Reflect.has(data, 'code') && (code === ResultEnum.SUCCESS || code === 200);
    }
    if (hasSuccess) {
      if (success && message && options.successMessageMode === 'success') {
        //ä¿¡æ¯æˆåŠŸæç¤º
        createMessage.success(message);
      }
      // å…¼å®¹å¯¼å‡ºæ¥å£
      if (Object.prototype.toString.call(data) !== '[object Object]') return data;
      if (info) {
        return info;
      } else {
        return result;
      }
    }

    // åœ¨æ­¤å¤„æ ¹æ®è‡ªå·±é¡¹ç›®çš„å®é™…æƒ…å†µå¯¹ä¸åŒçš„codeæ‰§è¡Œä¸åŒçš„æ“ä½œ
    // å¦‚æœä¸å¸Œæœ›ä¸­æ–­å½“å‰è¯·æ±‚ï¼Œè¯·returnæ•°æ®ï¼Œå¦åˆ™ç›´æ¥æŠ›å‡ºå¼‚å¸¸å³å¯
    let timeoutMsg = '';
    switch (code) {
      case ResultEnum.TIMEOUT:
        timeoutMsg = 'ç™»å½•è¶…æ—¶,è¯·é‡æ–°ç™»å½•!';
        const userStore = useUserStoreWithOut();
        userStore.setToken(undefined);
        userStore.logout(true);
        break;
      default:
        if (message) {
          timeoutMsg = message;
        }
    }

    // errorMessageMode=â€˜modalâ€™çš„æ—¶å€™ä¼šæ˜¾ç¤ºmodalé”™è¯¯å¼¹çª—ï¼Œè€Œä¸æ˜¯æ¶ˆæ¯æç¤ºï¼Œç”¨äºä¸€äº›æ¯”è¾ƒé‡è¦çš„é”™è¯¯
    // errorMessageMode='none' ä¸€èˆ¬æ˜¯è°ƒç”¨æ—¶æ˜ç¡®è¡¨ç¤ºä¸å¸Œæœ›è‡ªåŠ¨å¼¹å‡ºé”™è¯¯æç¤º
    if (options.errorMessageMode === 'modal') {
      createErrorModal({ title: 'é”™è¯¯æç¤º', content: timeoutMsg });
    } else if (options.errorMessageMode === 'message') {
      createMessage.error(timeoutMsg);
    }

    throw new Error(timeoutMsg || 'è¯·æ±‚å‡ºé”™ï¼Œè¯·ç¨å€™é‡è¯•');
  },

  // è¯·æ±‚ä¹‹å‰å¤„ç†config
  beforeRequestHook: (config, options) => {
    const { apiUrl, joinPrefix, joinParamsToUrl, formatDate, joinTime = true, urlPrefix } = options;

    if (joinPrefix) {
      config.url = `${urlPrefix}${config.url}`;
    }

    if (apiUrl && isString(apiUrl)) {
      config.url = `${apiUrl}${config.url}`;
    }
    const params = config.params || {};
    const data = config.data || false;
    formatDate && data && !isString(data) && formatRequestDate(data);
    if (config.method?.toUpperCase() === RequestEnum.GET) {
      if (!isString(params)) {
        // ç»™ get è¯·æ±‚åŠ ä¸Šæ—¶é—´æˆ³å‚æ•°ï¼Œé¿å…ä»ç¼“å­˜ä¸­æ‹¿æ•°æ®ã€‚
        config.params = Object.assign(params || {}, joinTimestamp(joinTime, false));
      } else {
        // å…¼å®¹restfulé£æ ¼
        config.url = config.url + params + `${joinTimestamp(joinTime, true)}`;
        config.params = undefined;
      }
    } else {
      if (!isString(params)) {
        formatDate && formatRequestDate(params);
        if (Reflect.has(config, 'data') && config.data && Object.keys(config.data).length > 0) {
          config.data = data;
          config.params = params;
        } else {
          // éGETè¯·æ±‚å¦‚æœæ²¡æœ‰æä¾›dataï¼Œåˆ™å°†paramsè§†ä¸ºdata
          config.data = params;
          config.params = undefined;
        }
        if (joinParamsToUrl) {
          config.url = setObjToUrlParams(config.url as string, Object.assign({}, config.params, config.data));
        }
      } else {
        // å…¼å®¹restfulé£æ ¼
        config.url = config.url + params;
        config.params = undefined;
      }
    }
    return config;
  },

  /**
   * @description: è¯·æ±‚æ‹¦æˆªå™¨å¤„ç†
   */
  requestInterceptors: (config: Recordable, options) => {
    // è¯·æ±‚ä¹‹å‰å¤„ç†config
    const token = getToken();
    if (token && (config as Recordable)?.requestOptions?.withToken !== false) {
      // jwt token
      config.headers.Authorization = options.authenticationScheme ? `${options.authenticationScheme} ${token}` : token;
      config.headers[ConfigEnum.TOKEN] = token;
      config.headers['ClientToken'] = token;
    }
    return config;
  },

  /**
   * @description: å“åº”æ‹¦æˆªå™¨å¤„ç†
   */
  responseInterceptors: (res: AxiosResponse<any>) => {
    return res;
  },

  /**
   * @description: å“åº”é”™è¯¯å¤„ç†
   */
  responseInterceptorsCatch: (error: any) => {
    const errorLogStore = useErrorLogStoreWithOut();
    errorLogStore.addAjaxErrorInfo(error);
    const { response, code, message, config } = error || {};
    const errorMessageMode = config?.requestOptions?.errorMessageMode || 'none';
    const msg: string = response?.data?.message ?? '';
    const err: string = error?.toString?.() ?? '';
    let errMessage = '';

    try {
      if (code === 'ECONNABORTED' && message.indexOf('timeout') !== -1) {
        errMessage = 'æ¥å£è¯·æ±‚è¶…æ—¶,è¯·åˆ·æ–°é¡µé¢é‡è¯•!';
      }
      if (err?.includes('Network Error')) {
        errMessage = 'ç½‘ç»œå¼‚å¸¸ï¼Œè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸!';
      }

      if (errMessage) {
        if (errorMessageMode === 'modal') {
          createErrorModal({ title: 'é”™è¯¯æç¤º', content: errMessage });
        } else if (errorMessageMode === 'message') {
          createMessage.error(errMessage);
        }
        return Promise.reject(error);
      }
    } catch (error: any) {
      throw new Error(error);
    }

    checkStatus(error?.response?.status, msg, errorMessageMode);
    // æ·»åŠ è‡ªåŠ¨é‡è¯•æœºåˆ¶ ä¿é™©èµ·è§ åªé’ˆå¯¹GETè¯·æ±‚
    const retryRequest = new AxiosRetry();
    const { isOpenRetry } = config.requestOptions.retryRequest;
    config.method?.toUpperCase() === RequestEnum.GET &&
      isOpenRetry &&
      // @ts-ignore
      retryRequest.retry(axiosInstance, error);
    return Promise.reject(error);
  },
};
7. è¯·æ±‚é…ç½®é¡¹ã€è°ƒç”¨å…¥å£
// axiosé…ç½®  å¯è‡ªè¡Œæ ¹æ®é¡¹ç›®è¿›è¡Œæ›´æ”¹ï¼Œåªéœ€æ›´æ”¹è¯¥æ–‡ä»¶å³å¯ï¼Œå…¶ä»–æ–‡ä»¶å¯ä»¥ä¸åŠ¨
import { VAxios } from './Axios';
import { ContentTypeEnum } from '@/enums/httpEnum';
import { useGlobSetting } from '@/hooks/setting';
import { deepMerge } from '@/utils';
import { CreateAxiosOptions } from './types';
import { transform } from './axiosTransform';

const globSetting = useGlobSetting();
const urlPrefix = globSetting.urlPrefix || '';

function createAxios(opt?: Partial<CreateAxiosOptions>) {
  return new VAxios(
    deepMerge(
      {
        timeout: 10 * 1000,
        authenticationScheme: '',
        // æ¥å£å‰ç¼€
        prefixUrl: urlPrefix,
        headers: { 'Content-Type': ContentTypeEnum.JSON },
        // æ•°æ®å¤„ç†æ–¹å¼
        transform,
        // é…ç½®é¡¹ï¼Œä¸‹é¢çš„é€‰é¡¹éƒ½å¯ä»¥åœ¨ç‹¬ç«‹çš„æ¥å£è¯·æ±‚ä¸­è¦†ç›–
        requestOptions: {
          // é»˜è®¤å°†prefix æ·»åŠ åˆ°url
          joinPrefix: true,
          // æ˜¯å¦è¿”å›åŸç”Ÿå“åº”å¤´ æ¯”å¦‚ï¼šéœ€è¦è·å–å“åº”å¤´æ—¶ä½¿ç”¨è¯¥å±æ€§
          isReturnNativeResponse: false,
          // éœ€è¦å¯¹è¿”å›æ•°æ®è¿›è¡Œå¤„ç†
          isTransformResponse: true,
          // postè¯·æ±‚çš„æ—¶å€™æ·»åŠ å‚æ•°åˆ°url
          joinParamsToUrl: false,
          // æ ¼å¼åŒ–æäº¤å‚æ•°æ—¶é—´
          formatDate: true,
          // æ¶ˆæ¯æç¤ºç±»å‹
          errorMessageMode: 'none',
          // æ¥å£åœ°å€
          apiUrl: globSetting.apiUrl,
          // æ¥å£æ‹¼æ¥åœ°å€
          urlPrefix: urlPrefix,
          //  æ˜¯å¦åŠ å…¥æ—¶é—´æˆ³
          joinTime: true,
          // å¿½ç•¥é‡å¤è¯·æ±‚
          ignoreCancelToken: true,
          // æ˜¯å¦æºå¸¦token
          withToken: true,
          retryRequest: {
            isOpenRetry: true,
            count: 5,
            waitTime: 100,
          },
        },
        withCredentials: false,
      },
      opt || {}
    )
  );
}

export const http = createAxios();
å¦‚æœé¡¹ç›®ä¸­å¤šä¸ªä¸åŒ api åœ°å€ï¼Œç›´æ¥åœ¨è¿™é‡Œå¯¼å‡ºå¤šä¸ªï¼Œåœ¨è¯·æ±‚é…ç½®ä¸­ä½¿ç”¨ä¸åŒçš„ url å³å¯
function createAxios(opt?: Partial<CreateAxiosOptions>) {}
export const defHttp = createAxios();

function createAxios2(opt?: Partial<CreateAxiosOptions>) {}

export const defHttp2 = createAxios2();
8. é¡¹ç›®ä¸­ä½¿ç”¨å¹¶è°ƒç”¨æ¥å£
ä¸ºäº†ç»Ÿä¸€ç®¡ç†é¡¹ç›®ä¸­ä½¿ç”¨åˆ°çš„æ¥å£ï¼Œå¯ä»¥ä¸“é—¨æ–°å»ºä¸ª api.ts æ–‡ä»¶å­˜æ”¾æŸä¸ªæ¨¡å—çš„æ¥å£
import { defHttp } from '/@/utils/http/axios';

enum Api {
  page = '/server/page/list',
    }

/**
 *  é¡µé¢é…ç½®åˆ—è¡¨
 * @param params
 * @returns
 */
export const list = (params) => {
  return defHttp.post({ url: Api.page, params });
};
é¡µé¢é€»è¾‘ä»£ç ä¸­å¼•å…¥æ¥å£å¹¶è°ƒç”¨ï¼š
import { list } from './api.ts';
......

onMounted(() => {
  getList();
});
const getList = () => {
  loading.value = true;
  const params = {
    name: name.value,
    age: age.value,
  };
  list(params)
    .then((res) => {
      if (res.items) {
        dataSource = res.items || [];
      }
    })
    .finally(() => {
      loading.value = false;
    });
};
åˆ°è¿™é‡ŒäºŒæ¬¡å°è£… Axios è¯·æ±‚å·²ç»åŸºæœ¬å®Œæˆï¼Œæœ¬æ–‡ä»£ç ä¸­ä¼šå¼•ç”¨åˆ°è®¸å¤šå…¶ä»–åœ°æ–¹çš„æ¨¡å—ï¼Œæˆ‘ä»¬å¯ä»¥å¿½ç•¥ï¼Œåªéœ€å…³æ³¨ axios ç›¸å…³çš„å¤„ç†é€»è¾‘ã€‚å…¶å®æˆ‘çš„ä»£ç æ˜¯åŸºäº vue-vben-admin æ¨¡æ¿çš„ï¼Œæ‰€ä»¥æœ‰äº›åœ°æ–¹ä¹Ÿè®¸ä¼šè¿‡åº¦å°è£…ï¼Œæˆ‘ä»¬ä¸»è¦å…³æ³¨å°è£…çš„é€»è¾‘ä»¥åŠæ³¨æ„äº‹é¡¹å³å¯æˆ‘å¸çš„ç®¡ç†åå°é¡¹ç›®ä¾¿æ˜¯åŸºäºè¯¥æ¨¡æ¿ï¼Œå› æ­¤è¶ç€å‘¨æœ«æ¢³ç†äº†ä¸€é axios ç›¸å…³çš„ä»£ç ï¼Œå¹¶åšäº†ä¸€äº›æ€»ç»“åˆ†äº«ç»™å¤§å®¶ï¼Œå¦‚æœæœ‰é”™è¯¯ä»¥åŠä¸åˆç†çš„åœ°æ–¹å¸Œæœ›æŒ‡å‡ºï¼Œå…±åŒè¿›æ­¥ï¼
 
9ï¼šè¯·æ±‚å‚æ•°åŠ å¯†
éœ€è¦è§£å†³çš„é—®é¢˜
â— ç”±äºç”¨æˆ·æ ‡è¯†ä¸ºå„é¡¹å‚æ•°çš„ç»„åˆï¼Œéœ€è¦é˜²æ­¢è¢«åˆ†æå‡ºæ ‡è¯†è§„åˆ™
â— å‰åç«¯æ•°æ®ä¸ºæ˜æ–‡ä¼ è¾“ï¼Œç”¨æˆ·å¯é€šè¿‡å¼€å‘è€…å·¥å…·æŸ¥çœ‹æ•°æ®
åœºæ™¯
ç”±äºé¡¹ç›®åˆ›å»ºä¹‹å‰åç«¯è®¾è®¡ä¸åˆç†ï¼Œå¯¼è‡´è¯¦æƒ…é¡µé“¾æ¥å‚æ•°idä¸ºé¡ºåºåºæ•°(ä¾‹ï¼š1,2,3â€¦ç­‰ç­‰)ï¼Œå®‰å…¨ç³»æ•°éå¸¸ä½ï¼ˆè™½ç„¶æˆ‘ä»¬å‰ç«¯åšäº†èœå•æƒé™ã€æŒ‰é’®æƒé™ã€Apiæƒé™ç­‰ç­‰ï¼‰ï¼Œç°åœ¨è¦å‰ç«¯è§£å†³ä¸‹æµè§ˆå™¨é“¾æ¥/æ¥å£å‚æ•°å®ç°åŠ å¯†
é¡¹ç›®æ­£å¸¸é“¾æ¥ï¼š http://xxx.com/xx/contract/draft/contract-draft-detail?id=26197&type=news&key=1667198460529
æˆ‘ä»¬æœ€ç»ˆéœ€è¦base64åŠ å¯†æˆè¿™ç§ï¼ˆå¦‚æœä¸æƒ³base64åŠ å¯†ä¹Ÿå¯æ¢æˆå…¶ä»–åŠ å¯†æ–¹å¼ ğŸ‘‡
å¦‚ï¼šRSAåŠ å¯†ã€AESåŠ å¯†ã€MD5åŠ å¯†ã€SHA256åŠ å¯†ä»¥åŠå›½å¯†ï¼‰
åŠ å¯†åçš„ï¼šontract/draft/contract-draft-detail?__params=eyJpZCI6MjYxOTcsInR5cGUiOiJuZXciLCJrZXkiOjE2NjcxOTg0NjA1Mjl9
è¦æƒ³å°†å‚æ•°åŠ å¯†ï¼Œæˆ‘è¿™é‡Œè®¾è®¡çš„æ˜¯ï¼Œå°†æ‰€æœ‰å‚æ•°ä»¥å¯¹è±¡çš„å½¢å¼è¿›è¡ŒåŠ å¯†ï¼Œå¦‚ä¸‹
æ­£å¸¸å‚æ•°æ ¼å¼ï¼š `id=26197&type=news&key=1667198460529`,
è½¬åŒ–æˆå¯¹è±¡:  {
	id: 26197,
	type: 'news',
	key: '1667198460529'
}

æ­£å¸¸æƒ…å†µä¸‹ï¼Œå¯ç›´æ¥ $route.query è·å–å‚æ•°å¯¹è±¡ï¼Œæˆ– window.location.search æ ¼å¼åŒ–è·å–ï¼Œæ ¼å¼åŒ–å‡½æ•°å¦‚ä¸‹
// URLå‚æ•°è½¬æˆå¯¹è±¡
export function urlPasseObj(url = '', isUrl) {
  const result = url.split('?')[isUrl ? 1 : 0]
  if (!result) {
    return {}
  }
  const list = result.split('&')
  const obj = {}
  list.map(item => {
    if (item) {
      const arr = item.split('=')
      const value = arr[1]
      obj[arr[0]] = value === undefined ? '' : value
    }
  })
  return obj
}


åŠ å¯†åéƒ½æ”¾åˆ°ä¸€ä¸ªå‚æ•°ä¸­ï¼Œè¿™é‡Œæˆ‘å‘½åä¸º __params
åŠ /è§£å¯†æ–¹æ³•å®ç°
è¿™é‡Œè¦æ³¨æ„çš„æ˜¯base64åŠ å¯†æ­£å¸¸æ˜¯å­—ç¬¦ä¸²(Stringç±»å‹)è¿›è¡ŒåŠ å¯†ï¼Œå¯¹å¯¹è±¡(Object)è¿›è¡ŒåŠ å¯†ï¼Œéœ€è¦é€šè¿‡JSON.parseè¿›è¡Œè½¬ä¹‰æˆStringç±»å‹
/**
 * base64(è§£å¯†)
 * @param {String} str è·³è½¬å‚æ•°ä¸ºbase64å­—ç¬¦ä¸²
 * @returns
 */
export const decryptBase64 = function(str) {
  // æ·»åŠ decodeURIComponentè§£å†³å…¶ä»–ç‰¹æ®Šå­—ç¬¦ï¼Œå¦‚ç­‰å·(=)ä¼šè½¬æˆ%3Dï¼Œå¯¼è‡´base64è§£å¯†å¤±è´¥
  const decryptQuery = str ? JSON.parse(base64.decode(decodeURIComponent(str))) : {}
  return decryptQuery
}

/**
 * base64(åŠ å¯†)
 * @param {Object || String} param è·³è½¬å‚æ•°å¯ä»¥ä¸ºå¯¹è±¡æˆ–è·¯å¾„å­—ç¬¦ä¸²
 * @returns
 */
export const encryptBase64 = function(param) {
  const encryptStr = base64.encode(JSON.stringify(param)) || ''
  return encryptStr
}

åŠ å¯†å¤„å¤„ç†ï¼Œè·¯ç”±æ‹¦æˆªè¯·æ±‚(å¤„ç†getè¯·æ±‚å‚æ•°)
request.interceptors.request.use(config => {
   if (config.method === 'get') {
    config.data = true
    // åˆ¤æ–­æ˜¯å¦æœ‰æºå¸¦å‚æ•°
    const isHash = config.url.includes('?')
    if (isHash) {
      // å°†urlä¸Šçš„å‚æ•°è°ƒæ•´åˆ°paramsä¸­ï¼Œç„¶åè°ƒæ•´æ¸…é™¤urlä¸Šçš„å‚æ•°
      // urlPasseObjæ–¹æ³•åœ¨ä¸Šæ–¹
      const urlParam = urlPasseObj(config.url, true)
      config.params = config.params ? { ...config.params, ...urlParam } : urlParam
      config.url = config.url.split('?')[0]
    }
    if (config.params) {
      config.params = {
        __params: encryptBase64(config.params)
      }
    }
  }
  return config
}, errorHandler)

è§£å¯†çš„å¤„ç†
watch: {
   '$route.query': {
     immediate: true,
     deep: true,
     handler(val) {
       if (val.__params) {
         const newQuery = decryptBase64(val?.__params)
         // åœ¨vueåŸå‹ä¸Šå®šä¹‰ä¸€ä¸ª
        //  Vue.prototype.$route_query = newQuery
        //  return
       }
      //  Vue.prototype.$route_query = val || {}
     }
   }
 }
 