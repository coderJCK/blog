## axios
### 避免重复请求
> 实现思路：
> 1. 使用 axios 的取消功能，为每个请求创建一个取消令牌。
> 2. 在发送请求之前，检查是否有相同的请求正在进行，如果有，则取消或忽略新的请求。
> 3. 请求完成后，从正在进行的请求列表中移除该请求。

```js
import axios from 'axios';

// 正在进行的请求的字典
const pendingRequests = new Map();

// 生成请求的唯一标识符，这里简单使用url和方法组合
function generateReqKey(config) {
  return `${config.url}&${config.method}`;
}

// 添加请求
function addRequest(config) {
  const requestKey = generateReqKey(config);
  config.cancelToken = config.cancelToken || new axios.CancelToken((cancel) => {
    if (!pendingRequests.has(requestKey)) {
      pendingRequests.set(requestKey, cancel);
    }
  });
}

// 移除请求
function removeRequest(config) {
  const requestKey = generateReqKey(config);
  if (pendingRequests.has(requestKey)) {
    const cancel = pendingRequests.get(requestKey);
    cancel(requestKey);
    pendingRequests.delete(requestKey);
  }
}

// 请求拦截器
axios.interceptors.request.use(config => {
  removeRequest(config); // 在请求开始前，对之前的请求做检查取消操作
  addRequest(config); // 将当前请求添加到pendingRequests对象中
  return config;
}, error => {
  return Promise.reject(error);
});

// 响应拦截器
axios.interceptors.response.use(response => {
  removeRequest(response.config); // 从pendingRequests中移除请求
  return response;
}, error => {
  removeRequest(error.config || {});
  if (axios.isCancel(error)) {
    console.log('重复请求被取消', error.message);
  }
  return Promise.reject(error);
});

```

### 监听网络进度

1.xhr实现
> 实现思路：
> XMLHttpRequest 是原生的浏览器 API，可用于发送 HTTP 请求，它提供了事件监听器> 来跟踪请求的进度。
> - XMLHttpRequest 对象的 progress 事件会在下载数据时触发，event.> lengthComputable 用于判断服务器是否返回了文件的总大小。
> - 如果 lengthComputable 为 true，可以通过 event.loaded（已下载的字节数和 event.total（文件总字节数）计算下载进度。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMLHttpRequest 监听网络进度</title>
</head>

<body>
    <button id="fetchButton">发起请求</button>
    <div id="progressBar" style="width: 300px; height: 20px; border: 1px solid #ccc;"></div>
    <div id="progressText"></div>

    <script>
        const fetchButton = document.getElementById('fetchButton');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');

        fetchButton.addEventListener('click', () => {
            const xhr = new XMLHttpRequest();
            xhr.open('GET', 'https://example.com/large-file.zip'); // 替换为实际的大文件 URL

            // 监听下载进度
            xhr.addEventListener('progress', (event) => {
                if (event.lengthComputable) {
                    const percentComplete = (event.loaded / event.total) * 100;
                    progressBar.style.width = percentComplete + '%';
                    progressText.textContent = `下载进度: ${percentComplete.toFixed(2)}%`;
                }
            });

            // 监听请求完成
            xhr.addEventListener('load', () => {
                progressText.textContent = '下载完成';
            });

            // 监听请求错误
            xhr.addEventListener('error', () => {
                progressText.textContent = '下载出错';
            });

            xhr.send();
        });
    </script>
</body>

</html>
```

2.fetch 实现
> 实现思路：
> fetch API 本身不直接支持进度监听，但可以结合 ReadableStream 来实现。
> - 使用 fetch 发起请求后，通过 response.body.getReader() 获取一个 ReadableStream 的读取器。
> - Content-Length 头信息包含了文件的总大小，通过不断读取数据块并累加已接收的字节数，计算下载进度。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fetch 监听网络进度</title>
</head>

<body>
    <button id="fetchButton">发起请求</button>
    <div id="progressBar" style="width: 300px; height: 20px; border: 1px solid #ccc;"></div>
    <div id="progressText"></div>

    <script>
        const fetchButton = document.getElementById('fetchButton');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');

        fetchButton.addEventListener('click', async () => {
            try {
                const response = await fetch('https://example.com/large-file.zip'); // 替换为实际的大文件 URL
                const reader = response.body.getReader();
                const contentLength = +response.headers.get('Content-Length');

                let receivedLength = 0;
                while (true) {
                    const { done, value } = await reader.read();

                    if (done) {
                        break;
                    }

                    receivedLength += value.length;
                    const percentComplete = (receivedLength / contentLength) * 100;
                    progressBar.style.width = percentComplete + '%';
                    progressText.textContent = `下载进度: ${percentComplete.toFixed(2)}%`;
                }

                progressText.textContent = '下载完成';
            } catch (error) {
                progressText.textContent = '下载出错';
            }
        });
    </script>
</body>

</html>
```

3.axios实现
> 实现思路：
> axios 是一个流行的基于 Promise 的 HTTP 客户端，它提供了 onDownloadProgress 事件来监听下载进度。
> - axios.get 方法的第二个参数可以传入配置对象，其中 onDownloadProgress 是一个回调函数，会在下载过程中不断触发。
> - 通过 progressEvent.loaded 和 progressEvent.total 计算下载进度。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axios 监听网络进度</title>
    <!-- 引入 axios -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>

<body>
    <button id="fetchButton">发起请求</button>
    <div id="progressBar" style="width: 300px; height: 20px; border: 1px solid #ccc;"></div>
    <div id="progressText"></div>

    <script>
        const fetchButton = document.getElementById('fetchButton');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');

        fetchButton.addEventListener('click', () => {
            axios.get('https://example.com/large-file.zip', { // 替换为实际的大文件 URL
                responseType: 'blob',
                onDownloadProgress: (progressEvent) => {
                    if (progressEvent.lengthComputable) {
                        const percentComplete = (progressEvent.loaded / progressEvent.total) * 100;
                        progressBar.style.width = percentComplete + '%';
                        progressText.textContent = `下载进度: ${percentComplete.toFixed(2)}%`;
                    }
                }
            })
           .then(() => {
                progressText.textContent = '下载完成';
            })
           .catch(() => {
                progressText.textContent = '下载出错';
            });
        });
    </script>
</body>

</html>
```

### 实现并发请求

> 实现思路：Promise.all && Promise.allSettled
> Promise.all 和 Promise.allSettled都可以接收一个由多个 Promise 组成的可迭代对象，它会并行执行这些 Promise，并在所有 Promise 都成功解决时返回一个新的 Promise，该 Promise 会以一个包含所有结果的数组来解决；如果其中任何一个 Promise 被拒绝，则整个 Promise.all 会立即被拒绝。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Axios 并发请求</title>
    <!-- 引入 axios -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
</head>

<body>
    <script>
        const urls = ['https://api.example.com/data1', 'https://api.example.com/data2', 'https://api.example.com/data3'];
        const requests = urls.map(url => axios.get(url));

        axios.all(requests)
           .then(axios.spread((...responses) => {
                responses.forEach((response, index) => {
                    console.log(`Response from request ${index + 1}:`, response.data);
                });
            }))
           .catch(error => {
                console.error('Error in one or more requests:', error);
            });
    </script>
</body>

</html>
```

## 网络预请求
> **DNS预解析**。在进行 HTTP 请求时，浏览器首先需要通过 DNS 解析将域名转换为对应的 IP 地址，这个过程可能会带来一定的延迟。DNS 预解析就是提前让浏览器进行域名解析，当后续真正发起请求时可以直接使用解析好的 IP 地址，从而节省时间。
> **预连接**。预连接不仅会提前进行 DNS 解析，还会建立 TCP 连接和可选的 TLS 握手，这样当真正发起请求时，就可以直接进行数据传输，进一步减少延迟。
> **预获取**。预获取是指提前下载一些后续可能会用到的资源，如图片、脚本、样式表等，并将其存储在浏览器缓存中。当页面需要使用这些资源时，可以直接从缓存中读取，而无需再次发起网络请求。
> **预渲染**。预渲染会在后台加载整个页面，并进行渲染，当用户访问该页面时，可以立即显示已经渲染好的内容，实现几乎无延迟的页面加载。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 预解析百度的域名 -->
    <link rel="dns-prefetch" href="https://www.baidu.com">
    <!-- 预连接谷歌字体的域名 -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <!-- 预获取一张图片 -->
    <link rel="prefetch" href="https://example.com/large-image.jpg">
    <!-- 预渲染另一个页面 -->
    <link rel="prerender" href="https://example.com/another-page.html">
    <title>DNS 预解析示例</title>
</head>
<body>
    <!-- 页面内容 -->
</body>
</html>
```

## http && WebSocket

> WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，它允许浏览器和服务器之间进行实时通信。与 HTTP 的区别如下：
> - **连接方式**：HTTP 是无状态的请求 - 响应协议，每次请求都需要建立新的连接；WebSocket 是持久连接，建立连接后可以持续进行数据传输。
> - **通信方式**：HTTP 是单向通信，客户端发起请求，服务器响应；WebSocket 是全双工通信，客户端和服务器可以同时发送和接收数据。
> - **实时性**：HTTP 不适合实时通信，每次通信都有一定的延迟；WebSocket 具有低延迟的特点，适合实时性要求较高的场景，如聊天应用、实时数据推送等。


## 资源提示关键词